<?xml version="1.0"?>
<doc>
    <assembly>
        "Lumia.Sense (Phone)"
    </assembly>
    <members>
        <member name="F:Lumia.Sense.RouteTrackerSimulator.m_fLoop">
            <summary>Should simulator loop events</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerSimulator.m_recordingDuration">
            <summary> Recording duration </summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerSimulator.m_recordingStart">
            <summary> Recording start timestamp </summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerSimulator.m_simulationStart">
            <summary>Simulation start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerSimulator.m_route">
            <summary> simulated route </summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.#ctor(Lumia.Sense.SenseRecording,System.UInt64)">
            <summary>
Constructor
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Start time for simulation.</param>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.DeactivateAsync">
            <summary>
Closes the connection to sensor
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.ActivateAsync">
            <summary>
Re-establishes connection to sensor, if not already available
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="P:Lumia.Sense.RouteTrackerSimulator.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.GetPointAtAsync(Windows.Foundation.DateTime)">
            <summary>
Returns the location of the device at given time.
</summary>
            <param name="timestamp">time stamp</param>
            <returns>device location at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The available data extends only up to last 10 days.
</remarks>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.GetRouteAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns the route the device moved during the given time period.
</summary>
            <param name="periodFrom">start time</param>
            <param name="span">time span</param>
            <returns>route for the given time period</returns>
            <remarks>
The available route data extends only up to last 10 days.
</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording,Windows.Foundation.DateTime)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Start time for simulation.</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerSimulator.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="T:Lumia.Sense.RouteTrackerSimulator">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
visited by the device.
</summary>
            <remarks>
This entity monitors several primitive sensor values, such as the device's geographic 
location, to identify a geographic location visited frequently. The most frequented
places are then classified using various heuristics into a kind of a place. The 
classification is best effort and should not be expected to yield full accuracy
in all styles of device usage. An application can and should implement a mapping
from this pre-defined classification of places into concepts and visuals releavant
in the application context.
</remarks>
        </member>
        <member name="M:Lumia.Sense.StepCounter.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounter.IsSupportedAsync">
            <summary>
Returns whether the sensor is supported by the device or not.
</summary>
            <returns>
                <c>true</c> if the sensor is supported, <c>false</c>otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounter.DeactivateAsync">
            <summary>
Close the communication with underlying sensor, this explicitly closes the communication channel.
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounter.ActivateAsync">
            <summary>
Reestablish the communication channel with underlying sensor, if not already exists
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="P:Lumia.Sense.StepCounter.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounter.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounter.GetStepCountAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the step count at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>Please note that this method only returns data from history which is recorded at five minute intervals.
Therefore the data can be up to five minutes old. If you need to get the current reading, use <see cref="M:Lumia.Sense.StepCounter.GetCurrentReadingAsync" />.</paragraph></remarks>
            <param name="timestamp">time to get the step count for</param>
            <returns>Step count at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.StepCounter" /> and fetch steps from two hours ago.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading steps = await stepCounter.GetStepCountAtAsync( DateTime.Now.AddHours( -2 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.StepCounter.GetStepCountHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of step counts during given time period. Data granularity is usually around five minutes.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <returns>Step count history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>Please note that this method only returns data from history which is recorded at five minute intervals.
Therefore the data can be up to five minutes old. If you need to get the current reading, use <see cref="M:Lumia.Sense.StepCounter.GetCurrentReadingAsync" />.</paragraph><paragraph>If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the step count at the start of the period 
before the first actual event within that period.</paragraph></remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.StepCounter" /> and fetch steps from past hour.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
IList&lt;StepCounterReading&gt; steps = await stepCounter.GetStepCountHistoryAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.StepCounter.GetCurrentReadingAsync">
            <summary>
Gets the current reading.
</summary>
            <returns>
The current reading of the sensor.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />. 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained currently.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.StepCounter" /> and fetch a current
number of steps.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading currentSteps = await stepCounter.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.StepCounter.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation. Throws exception if sensor is not supported on the device.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SenseNotAvailable" />, <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.IncompatibleSDK" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.StepCounter" />.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
</code></example>
        </member>
        <member name="T:Lumia.Sense.StepCounter">
            <summary>
Represents a step counter sensor.
</summary>
            <remarks>
This sensor returns the user's step count information.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.StepCounter" /> and fetch a current
number of steps.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading currentSteps = await stepCounter.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.IsSupportedAsync">
            <summary>
Returns whether the sensor is supported by the device or not.
</summary>
            <returns>
                <c>true</c> if the sensor is supported, <c>false</c>otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.DeactivateAsync">
            <summary>
Close the communication with underlying sensor, this explicitly closes the communication channel.
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.ActivateAsync">
            <summary>
Reestablish the communication channel with underlying sensor, if not already exists
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="P:Lumia.Sense.RouteTracker.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.GetPointAtAsync(Windows.Foundation.DateTime)">
            <summary>
Returns the location of the device at given time.
</summary>
            <param name="timestamp">Time stamp</param>
            <returns>Device location at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />,  
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to last 10 days. The return value 
is <c>null</c> in case route point is not available for the given time.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.RouteTracker" /> and fetch a route
point from one hour ago.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
RoutePoint RoutePoint = await routeTracker.GetPointAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.GetRouteAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns the route the device moved during the given time period.
</summary>
            <param name="periodFrom">Start time</param>
            <param name="span">Time span</param>
            <returns>Route for the given time period</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available route data extends only up to last 10 days.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.RouteTracker" /> and fetch a route
history from one hour ago to now.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
IList&lt;RoutePoint&gt; routePoints = await routeTracker.GetRouteAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.RouteTracker.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation. Throws exception if sensor is not supported on the device.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SenseNotAvailable" />, <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.IncompatibleSDK" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.RouteTracker" /><code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
</code></example>
        </member>
        <member name="T:Lumia.Sense.RouteTracker">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
visited by the device.
</summary>
            <remarks>
Route points are collected passively, i.e. it won't actively track user's location with GPS,
accuracy of route points reflects the used positioning technology.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.RouteTracker" /> and fetch a route
point from one hour ago.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
RoutePoint routePoint = await routeTracker.GetPointAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_recordingEnd">
            <summary>Recording end timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_recordingStart">
            <summary>Recording start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_supportedActivities">
            <summary>Activities supported by the sensor</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_fRecording">
            <summary>Are we currently recording?</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_activityMonitor">
            <summary>Activity monitor sensor</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_csRecorder">
            <summary>Synchronization object</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorRecorder.m_readingHistory">
            <summary>Container for reading history</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.OnReadingChanged(Lumia.Sense.IActivityMonitor,Lumia.Sense.ActivityMonitorReading)">
            <summary>
Called when activity changes
</summary>
            <param name="source">source object</param>
            <param name="value">new activity</param>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.StopAsync">
            <summary>
Stops the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.StartAsync">
            <summary>
Starts the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorRecorder.#ctor(Lumia.Sense.IActivityMonitor)">
            <summary>
Constructor
</summary>
            <param name="activityMonitor">activity monitor sensor</param>
        </member>
        <member name="T:Lumia.Sense.ActivityMonitorRecorder">
            <summary>
Activity monitor recorder
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.OnNotificationReceived(System.Object,Lumia.Internal.HMBClient.HMBMessageEventArgs)">
            <summary>
Called when notification type HID input report is received
</summary>
            <param name="sender">sender object</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.IsSupportedAsync">
            <summary>
Returns whether the sensor is supported by the device or not.
</summary>
            <returns>
                <c>true</c> if the sensor is supported, <c>false</c>otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.DeactivateAsync">
            <summary>
Close the communication with underlying sensor, this explicitly closes the communication channel.
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.ActivateAsync">
            <summary>
Reestablish the communication channel with underlying sensor, if not already exists
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="P:Lumia.Sense.PlaceMonitor.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.GetPlaceAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the place at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days. The return value is <c>null</c> in case device 
was not in known place at the given time.
</remarks>
            <param name="timestamp">time to get the place for</param>
            <returns>Place at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />,  
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" /> and use 
it to get place visited an hour ago.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetPlaceAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.GetPlaceHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of places visited during given time period.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <returns>Place history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, <see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" /> and use 
it to get place history for the past hour.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
IList&lt;Place&gt; places = await placeMonitor.GetPlaceHistoryAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.GetKnownPlacesAsync">
            <summary>
Gets the set of currently known places.
</summary>
            <returns>
The current list of known places.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" /> and query 
for known places.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
IList&lt;Place&gt; knownPlaces = await placeMonitor.GetKnownPlacesAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.GetCurrentPlaceAsync">
            <summary>
Gets the current place.
</summary>
            <returns>
The current place.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value is <c>null</c> in case device is not in known place or
reading cannot be obtained currently.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" /> and use 
it to get current place.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetCurrentPlaceAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitor.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation. Throws exception if sensor is not supported on the device.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SenseNotAvailable" />, <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.IncompatibleSDK" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" />.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
</code></example>
        </member>
        <member name="E:Lumia.Sense.PlaceMonitor.PlaceChanged">
            <summary>
Raised each time the place the device enters or leaves one of the known places 
or when a place is removed from the set of known places.
</summary>
            <example>
The following example shows how to enable and register for place change events.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
placeMonitor.Enabled = true;
placeMonitor.PlaceChanged += placeMonitor_PlaceChanged;
</code>
Here is the handler for place change events.
<code lang="C#">
private void placeMonitor_PlaceChanged( object source, PlaceChange placeChange )
{
    // Handle place change event here
}
</code></example>
        </member>
        <member name="P:Lumia.Sense.PlaceMonitor.Enabled">
            <summary>
Enables or disables place change event monitoring.
</summary>
            <remarks>
                <see cref="E:Lumia.Sense.PlaceMonitor.PlaceChanged" /> events occur only while the property is set to <c>true</c>. However, sensor's 
current value can be queried via <see cref="M:Lumia.Sense.PlaceMonitor.GetCurrentPlaceAsync" /> even when the property is <c>false</c>.
</remarks>
        </member>
        <member name="T:Lumia.Sense.PlaceMonitor">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
frequently visited by the device.
</summary>
            <remarks>
This entity monitors several primitive sensor values, such as the device's geographic 
location, to identify a geographic location visited frequently. The most frequented
places are then classified using various heuristics into a kind of a place. The 
classification is best effort and should not be expected to yield full accuracy
in all styles of device usage. An application can and should implement a mapping
from this pre-defined classification of places into concepts and visuals releavant
in the application context.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.PlaceMonitor" /> and use 
it to get current place.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetCurrentPlaceAsync();
</code></example>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_recordingEnd">
            <summary>Recording end timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_recordingStart">
            <summary>Recording start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_fRecording">
            <summary>Are we currently recording?</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_previousTimestamp">
            <summary>Previous data poll timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_dataPollTimer">
            <summary>Data poll timer</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_routeTracker">
            <summary>Route tracker sensor</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_csRecorder">
            <summary>Synchronization object</summary>
        </member>
        <member name="F:Lumia.Sense.RouteTrackerRecorder.m_readingHistory">
            <summary>Container for route points</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.FetchHistoryAsync">
            <summary>
Fetches history readings and adds them to memory store
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.StopAsync">
            <summary>
Stops the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.StartAsync">
            <summary>
Starts the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.RouteTrackerRecorder.#ctor(Lumia.Sense.IRouteTracker)">
            <summary>
Constructor
</summary>
            <param name="routeTracker">route tracker sensor</param>
        </member>
        <member name="T:Lumia.Sense.RouteTrackerRecorder">
            <summary>
Route tracker recorder
</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_recordingEnd">
            <summary>Recording end timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_recordingStart">
            <summary>Recording start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_fRecording">
            <summary>Are we currently recording?</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_currentReadingTimer">
            <summary>Current reading timer</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_dataPollTimer">
            <summary>Data poll timer</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_stepCounter">
            <summary>Step counter sensor</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_csRecorder">
            <summary>Synchronization object</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_currentReadingHistory">
            <summary>Container for current readings</summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterRecorder.m_dataPollHistory">
            <summary>Container for readings from data poll timer</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.InitializeDataPollTimer">
            <summary>
Initializes data poll timer, aligning the timer interval with system clock. Will stop and deallocate 
any previous instance. Note! Not thread safe!
</summary>
            <remarks>In order for the timer interval to be aligned with the system clock, you'll
need to start the timer immediately.</remarks>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.FetchCurrentReading">
            <summary>
Fetches current reading timer reading and adds it to memory store. Note! Not thread safe!
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.FetchDataPollReading">
            <summary>
Fetches data poll timer reading and adds it to memory store. Note! Not thread safe!
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.StopAsync">
            <summary>
Stops the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.StartAsync">
            <summary>
Starts the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterRecorder.#ctor(Lumia.Sense.IStepCounter)">
            <summary>
Constructor
</summary>
            <param name="stepCounter">step counter sensor</param>
        </member>
        <member name="T:Lumia.Sense.StepCounterRecorder">
            <summary>
Step counter recorder
</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_csSimulator">
            <summary>Synchronization object</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_currentChange">
            <summary> Current index of place m_placeChanges in simulation </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_currentHistory">
            <summary> Current index of m_placeHistory in simulation </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_fLoop">
            <summary> Should simulator loop events </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_recordingDuration">
            <summary> Recording duration </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_recordingStart">
            <summary> Recording start timestamp </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_simulationStart">
            <summary> Simulation start timestamp </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_placeChanges">
            <summary> Simulated place changes </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_placeHistory">
            <summary> Simulated place history </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_knownPlaces">
            <summary> Simulated known places </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_initialKnownPlaces">
            <summary> Initial known places saved for resetting between loops </summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorSimulator.m_fEnabled">
            <summary> Is place monitoring enabled </summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetNextHistory">
            <summary>
Getter for next place history event
</summary>
            <returns>Next history place</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetNextChange">
            <summary>
Getter for next place change event
</summary>
            <returns>Next place change</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetLastEventStamp">
            <summary>
Getter for last events end timestamp
</summary>
            <returns>Timestamp of last event end time</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetNextEventStamp">
            <summary>
Getter for next events timestamp
</summary>
            <returns>Timestamp of next event</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetNextEventType">
            <summary>
Getter for next simulation event type
</summary>
            <returns>Type of next event</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.HandleCallback(System.Int64)">
            <summary>
Handler for simulation timer events
</summary>
            <param name="delta">delta between simulation start event and current time</param>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.#ctor(Lumia.Sense.SenseRecording,System.UInt64)">
            <summary>
Constructor
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Starting time for recording.</param>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.DeactivateAsync">
            <summary>
Closes the connection to sensor
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.ActivateAsync">
            <summary>
Re-establishes connection to sensor, if not already available
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="P:Lumia.Sense.PlaceMonitorSimulator.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetPlaceAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the place at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <param name="timestamp">time to get the place for</param>
            <returns>Place at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetPlaceHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of places visited during given time period.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <returns>Place history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetKnownPlacesAsync">
            <summary>
Gets the set of currently known places.
</summary>
            <returns>
                <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
The current list of known places.
</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetCurrentPlaceAsync">
            <summary>
Gets the current place.
</summary>
            <returns>
The current place.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained currently.
</remarks>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording,Windows.Foundation.DateTime)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Starting time for recording.</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorSimulator.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="E:Lumia.Sense.PlaceMonitorSimulator.PlaceChanged">
            <summary>
Raised each time the place the device enters or leaves one of the known places 
or when a place is removed from the set of known places.
</summary>
        </member>
        <member name="P:Lumia.Sense.PlaceMonitorSimulator.Enabled">
            <summary>
Enables or disables place change monitoring.
</summary>
            <remarks>
                <see cref="E:Lumia.Sense.PlaceMonitorSimulator.PlaceChanged" /> events occur only while the sensor is enabled. However, sensor's 
current value can be queried via <see cref="M:Lumia.Sense.PlaceMonitorSimulator.GetCurrentPlaceAsync" /> even when the sensor is not 
enabled.
</remarks>
        </member>
        <member name="F:History">
            <summary> History event </summary>
        </member>
        <member name="F:Change">
            <summary> Change event </summary>
        </member>
        <member name="F:None">
            <summary> No more events </summary>
        </member>
        <member name="T:Lumia.Sense.PlaceMonitorSimulator.EventType">
            <summary>
Indicates the type of event.
</summary>
        </member>
        <member name="T:Lumia.Sense.PlaceMonitorSimulator">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
visited by the device.
</summary>
            <remarks>
This entity monitors several primitive sensor values, such as the device's geographic 
location, to identify a geographic location visited frequently. The most frequented
places are then classified using various heuristics into a kind of a place. The 
classification is best effort and should not be expected to yield full accuracy
in all styles of device usage. An application can and should implement a mapping
from this pre-defined classification of places into concepts and visuals releavant
in the application context.
</remarks>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_recordingEnd">
            <summary>Recording end timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_recordingStart">
            <summary>Recording start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_fRecording">
            <summary>Are we currently recording?</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_previousTimestamp">
            <summary>Previous data poll timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_dataPollTimer">
            <summary>Data poll timer</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_placeMonitor">
            <summary>Place monitor sensor</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_csRecorder">
            <summary>Synchronization object</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_placeChanges">
            <summary>Container for place changes</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_placeHistory">
            <summary>Container for place history</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceMonitorRecorder.m_knownPlaces">
            <summary>Container for known places</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.FetchHistoryAsync">
            <summary>
Fetches history readings and adds them to memory store
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.OnPlaceChanged(System.Object,Lumia.Sense.PlaceChange)">
            <summary>
Called when activity changes
</summary>
            <param name="source">source object</param>
            <param name="value">new place</param>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.StopAsync">
            <summary>
Stops the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.StartAsync">
            <summary>
Starts the recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.PlaceMonitorRecorder.#ctor(Lumia.Sense.IPlaceMonitor)">
            <summary>
Constructor
</summary>
            <param name="placeMonitor">place monitor sensor</param>
        </member>
        <member name="T:Lumia.Sense.PlaceMonitorRecorder">
            <summary>
Place monitor recorder
</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_fLoop">
            <summary>Should simulator loop events</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_recordingDuration">
            <summary>Recording duration</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_recordingStart">
            <summary>Recording start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_simulationStart">
            <summary>Simulation start timestamp</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_activities">
            <summary>Simulated activities</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_fStopSimulation">
            <summary>Flag used to notify that simulation should stop</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_simulationTask">
            <summary>Background simulation task</summary>
        </member>
        <member name="F:Lumia.Sense.ActivityMonitorSimulator.m_activityMask">
            <summary>Bitmask describing observed activities</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.SimulationThreadFn">
            <summary>
Thread function for activity monitoring
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.SetActivities(&lt;unknown type&gt;)">
            <summary>
Returns currently monitored activities
</summary>
            <param name="value">activities to be monitored</param>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetActivities">
            <summary>
Returns currently monitored activities
</summary>
            <returns>Currently monitored activities</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.#ctor(Lumia.Sense.SenseRecording,System.UInt64)">
            <summary>
Constructor
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Start time for simulation.</param>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.DeactivateAsync">
            <summary>
Closes the connection to sensor
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.ActivateAsync">
            <summary>
Re-establishes connection to sensor, if not already available
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitorSimulator.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording,Windows.Foundation.DateTime)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Starting time for recording.</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetActivityAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the device activity at given time.
</summary>
            <param name="timestamp">time stamp</param>
            <returns>Activity at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetActivityHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of activities occured during given time period.
</summary>
            <param name="periodFrom">time period start</param>
            <param name="span">time period length</param>
            <returns>Activity history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>The returned list includes all activity monitor readings within the given time pediod.
If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the activity state of the device at the start of the period 
before the first actual activity event within that period.</paragraph></remarks>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetSupportedActivitiesAsync">
            <summary>
Returns bitmask of the activities that can be detected on this device.
</summary>
            <returns>Bitmask of the activities that can be detected on this device</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitorSimulator.GetCurrentReadingAsync">
            <summary>
Gets the current activity
</summary>
            <returns>Current activity</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained.
</remarks>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitorSimulator.SubscribedActivities">
            <summary>
Returns bitmask of activities the client is interested in.
</summary>
            <returns>Bitmask of activities the client is interested in</returns>
            <remarks>
                <paragraph>By default, no activities will be included in the mask. In order 
for the client to receive activity notifications is must first
set the mask value as a bitwise OR of the activities it is interested in.
It is recommended to keep the mask minimal in order to optimize resource usage
during activity monitoring.</paragraph>
            </remarks>
        </member>
        <member name="E:Lumia.Sense.ActivityMonitorSimulator.ReadingChanged">
            <summary>
Occurs each time one of the activity modes specified in <see cref="P:Lumia.Sense.ActivityMonitorSimulator.SubscribedActivities" /> starts or ends.
</summary>
            <remarks>
An application may register a handler for this event to be notified of activity changes as 
an alternative to actively polling the values using <see cref="M:Lumia.Sense.ActivityMonitorSimulator.GetCurrentReadingAsync" />.
</remarks>
        </member>
        <member name="T:Lumia.Sense.ActivityMonitorSimulator">
            <summary>
Represents an activity state monitor sensor.
</summary>
            <remarks>
This sensor returns the user's activity state values derived from
various sources of sensor and contextual information within the device.
</remarks>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.PrepareActivityMonitorReading(HIDMessage.ActivityMonitorReading!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
            <summary>
Creates new activity monitor reading based on the given data
</summary>
            <param name="reading">activity monitor reading HID message</param>
            <param name="mask">activity class mask</param>
            <returns>Activity monitor reading populated with the given data</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.OnNotificationReceived(System.Object,Lumia.Internal.HMBClient.HMBMessageEventArgs)">
            <summary>
Called when HID input report is received
</summary>
            <param name="sender">sender object</param>
            <param name="e">event arguments</param>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.IsSupportedAsync">
            <summary>
Returns whether the sensor is supported by the device or not.
</summary>
            <returns>
                <c>true</c> if the sensor is supported, <c>false</c>otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.DeactivateAsync">
            <summary>
Close the communication with underlying sensor, this explicitly closes the communication channel.
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.ActivateAsync">
            <summary>
Reestablish the communication channel with underlying sensor, if not already exists
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitor.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SenseNotAvailable" />, <see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" />, 
<see cref="F:Lumia.Sense.SenseError.IncompatibleSDK" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" />.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.GetActivityAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the device activity at given time.
</summary>
            <param name="timestamp">Time stamp</param>
            <returns>Activity at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" /> and use 
it to get activity from one hour ago.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading activity = await activityMonitor.GetActivityAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.GetActivityHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of activities occured during given time period.
</summary>
            <param name="periodFrom">Time period start</param>
            <param name="span">Time period length</param>
            <returns>Activity history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />,  
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>The returned list includes all activity monitor readings within the given time pediod.
If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the activity state of the device at the start of the period 
before the first actual activity event within that period.</paragraph></remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" /> and use 
it to get activity history from past 24 hours.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
IList&lt;ActivityMonitorReading&gt; activities = await activityMonitor.GetActivityHistoryAsync( DateTime.Now.AddDays( -1 ), TimeSpan.FromDays( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.GetSupportedActivitiesAsync">
            <summary>
Returns activities that can be detected by this device.
</summary>
            <returns>Activities that can be detected by this device</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" /> and use 
it to get supported activities.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
Activities activities = await activityMonitor.GetSupportedActivitiesAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.ActivityMonitor.GetCurrentReadingAsync">
            <summary>
Gets the current activity
</summary>
            <returns>Current activity</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" /> and use 
it to get current activity.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading reading = await activityMonitor.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitor.SubscribedActivities">
            <summary>
Returns bitmask of activities the client is interested in.
</summary>
            <returns>Bitmask of activities the client is interested in</returns>
            <remarks>
                <paragraph>By default, no activities will be included in the mask. In order 
for the client to receive activity notifications is must first
set the mask value as a bitwise OR of the activities it is interested in.
It is recommended to keep the mask minimal in order to optimize resource usage
during activity monitoring.</paragraph>
            </remarks>
        </member>
        <member name="E:Lumia.Sense.ActivityMonitor.ReadingChanged">
            <summary>
Occurs each time one of the activity modes specified in <see cref="P:Lumia.Sense.ActivityMonitor.SubscribedActivities" /> starts or ends.
</summary>
            <remarks>
An application may register a handler for this event to be notified of activity changes as 
an alternative to actively polling the values using <see cref="M:Lumia.Sense.ActivityMonitor.GetCurrentReadingAsync" />.
</remarks>
            <example>
The following example shows how to register for running and walking activity events.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
activityMonitor.SubscribedActivities = Activities.Running | Activities.Walking;
activityMonitor.ReadingChanged += activityMonitor_ReadingChanged;
</code>
Here is the handler for activity change events.
<code lang="C#">
private void activityMonitor_ReadingChanged( IActivityMonitor source, ActivityMonitorReading value )
{
    // Handle activity change event here
}
</code></example>
        </member>
        <member name="T:Lumia.Sense.ActivityMonitor">
            <summary>
Represents an activity state monitor sensor.
</summary>
            <remarks>
This sensor returns the user's activity state values derived from
various sources of sensor and contextual information within the device.
</remarks>
            <example>
The following example shows how to get the <see cref="T:Lumia.Sense.ActivityMonitor" /> and use 
it to get current activity.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading reading = await activityMonitor.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="M:ActivityClassToSubscribedClass(System.UInt64,System.UInt64)">
@COPYRIGHT  Copyright (c) 2013-2014 Microsoft Mobile and/or its subsidiary(-ies).
            All Rights reserved.
            This software, including documentation, is protected by copyright
            controlled by Nokia Corporation. All rights are reserved. Copying,
            including reproducing, storing, adapting or translating, any or all
            of this material requires the prior written consent of Nokia Corporation.
            This material also contains confidential information which may not be
            disclosed to others * without the prior written consent of Nokia.

@CONTACT    toni.kettula@nokia.com

@MODULENAME Module Name: NokiaActClassMapping.h

@ABSTRACT   Abstract:
            Functions for mapping a detected activity class to the reported
            class based on the class mask that the client has subscribed to

@CLASS      File Class:
            sensitive

</member>
        <member name="M:HandleStandardErrors(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Handles standard errors received from Sense service. Will throw appropriate exceptions on
errors.
</summary>
            <remarks>This method will throw an exception whenever the status is not S_OK so be sure to
handle custom errors codes prior to calling this method if you don't want a generic error
exception to be thrown.
</remarks>
        </member>
        <member name="M:GetTimestamp">
            <summary>
Returns current timestamp
</summary>
            <returns>current timestamp</returns>
        </member>
        <member name="M:MapActivitiesToActivityClassMask(&lt;unknown type&gt;)">
            <summary>
Maps managed activities bitmask to native activity class bitmask
</summary>
            <param name="activityMask">managed activities bitmask</param>
            <returns>native activity class bitmask</returns>
        </member>
        <member name="M:MapFromActivityClassToActivity(System.UInt64)">
            <summary>
Maps native activity class to managed activity
</summary>
            <param name="activityClass">native activity class</param>
            <returns>managed activity</returns>
        </member>
        <member name="M:MapFromActivityClassToActivities(System.UInt64)">
            <summary>
Maps native activity class bitmask to managed activities bitmask
</summary>
            <param name="activityClass">native activity class bitmask</param>
            <returns>managed activities bitmask</returns>
        </member>
        <member name="M:LogTxtMessage(System.Char!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
            <summary>
Writes message to log file
</summary>
            <param name="format">format string</param>
        </member>
        <member name="D:ACTIVITY_CLASS">
@Copyright  Copyright (c) 2012-2014 Microsoft Mobile and/or its subsidiary(-ies).
            All Rights reserved.
            This software, including documentation, is protected by copyright
            controlled by Nokia Corporation. All rights are reserved. Copying,
            including reproducing, storing, adapting or translating, any or all
            of this material requires the prior written consent of Nokia Corporation.
            This material also contains confidential information which may not be
            disclosed to others * without the prior written consent of Nokia.

@CONTACT    toni.kettula@nokia.com, juha.rakkola@nokia.com

@MODULENAME Module Name: NokiaActivityDetectionApiV2.h

@ABSTRACT   Abstract:
            API header for activity detection service. The API allows clients to
            subscribe to notifications about activity state changes.

@CLASS      File Class:
            sensitive

</member>
        <member name="M:Lumia.Sense.HidController.CreateBroker">
            <summary>
Create the HIdMessageBroker client instance, if its already created and valid this method does nothing
</summary>
        </member>
        <member name="M:Lumia.Sense.HidController.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.HidController.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.HidController.DeactivateAsync(Lumia.Sense.HIDClientId)">
            <summary>
Close the communication with HID device, this explicitly closes the HidDevice handle
</summary>
            <param name="clientId">client id</param>
            <returns>asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.HidController.ActivateAsync(Lumia.Sense.HIDClientId)">
            <summary>
Initialize the communication with HID device
</summary>
            <param name="clientId">client id</param>
            <returns>asynchronous task</returns>
        </member>
        <member name="P:Lumia.Sense.HidController.Client">
            <summary>
Returns HID message broker client instance
</summary>
            <returns>HID message broker client instance</returns>
        </member>
        <member name="M:Lumia.Sense.HidController.GetDefaultAsync(Lumia.Sense.HIDClientId)">
            <summary>
Returns instance to the HID controller
</summary>
            <param name="clientId">client id</param>
            <returns>HID controller instance</returns>
        </member>
        <member name="T:Lumia.Sense.HidController">
            <summary>
Controller class that takes care of sending and receiving HID reports 
</summary>
            <remarks>
This is a singleton class.
</remarks>
        </member>
        <member name="T:Lumia.Sense.HIDClientId">
            <summary>
HID client ids
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesEnd">
            <summary>
End of client ids used by utility functions
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesIsSensorSupported">
            <summary>
Is sensor supported
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesValidateSensor">
            <summary>
Sensor validator
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesGetVersionInfo">
            <summary>
Version info getter
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesGetApiState">
            <summary>
API state getter
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.UtilitiesBegin">
            <summary>
Beginning of client ids used by utility functions
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.PlaceMonitor">
            <summary>
Place monitor
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.RouteTracker">
            <summary>
Route tracker
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.StepCounter">
            <summary>
Step counter
</summary>
        </member>
        <member name="F:Lumia.Sense.HIDClientId.ActivityMonitor">
            <summary>
Activity monitor
</summary>
        </member>
        <member name="T:HMBServiceClientHelper">
            <summary>This is the helper class to simplify the usage of broker API.</summary>
            <remarks>This file is embedded due to template usage.</remarks>
        </member>
        <member name="T:HMBService">
            <summary>Represents a well-known service.</summary>
        </member>
        <member name="M:Lumia.Sense.IPlaceMonitor.GetPlaceAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the place at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days. The return value is <c>null</c> in case device 
was not in known place at the given time.
</remarks>
            <param name="timestamp">time to get the place for</param>
            <returns>Place at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <c>PlaceMonitor</c> and use 
it to get place visited an hour ago.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetPlaceAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IPlaceMonitor.GetPlaceHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of places visited during given time period.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <returns>Place history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, <see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <example>
The following example shows how to get the <c>PlaceMonitor</c> and use 
it to get place history for the past hour.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
IList&lt;Place&gt; places = await placeMonitor.GetPlaceHistoryAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IPlaceMonitor.GetKnownPlacesAsync">
            <summary>
Gets the set of currently known places.
</summary>
            <returns>
The current list of known places.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <c>PlaceMonitor</c> and query 
for known places.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
IList&lt;Place&gt; knownPlaces = await placeMonitor.GetKnownPlacesAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.IPlaceMonitor.GetCurrentPlaceAsync">
            <summary>
Gets the current place.
</summary>
            <returns>
The current place.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value is <c>null</c> in case device is not in known place or
reading cannot be obtained currently.
</remarks>
            <example>
The following example shows how to get the <c>PlaceMonitor</c> and use 
it to get current place.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetCurrentPlaceAsync();
</code></example>
        </member>
        <member name="E:Lumia.Sense.IPlaceMonitor.PlaceChanged">
            <summary>
Raised each time the place the device enters or leaves one of the known places 
or when a place is removed from the set of known places.
</summary>
            <example>
The following example shows how to enable and register for place change events.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
placeMonitor.Enabled = true;
placeMonitor.PlaceChanged += placeMonitor_PlaceChanged;
</code>
Here is the handler for place change events.
<code lang="C#">
private void placeMonitor_PlaceChanged( object source, PlaceChange placeChange )
{
    // Handle place change event here
}
</code></example>
        </member>
        <member name="P:Lumia.Sense.IPlaceMonitor.Enabled">
            <summary>
Enables or disables place change event monitoring.
</summary>
            <remarks>
                <see cref="E:Lumia.Sense.IPlaceMonitor.PlaceChanged" /> events occur only while the property is set to <c>true</c>. However, sensor's 
current value can be queried via <see cref="M:Lumia.Sense.IPlaceMonitor.GetCurrentPlaceAsync" /> even when the property is <c>false</c>.
</remarks>
        </member>
        <member name="T:Lumia.Sense.IPlaceMonitor">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
frequently visited by the device.
</summary>
            <remarks>
This entity monitors several primitive sensor values, such as the device's geographic 
location, to identify a geographic location visited frequently. The most frequented
places are then classified using various heuristics into a kind of a place. The 
classification is best effort and should not be expected to yield full accuracy
in all styles of device usage. An application can and should implement a mapping
from this pre-defined classification of places into concepts and visuals releavant
in the application context.
</remarks>
            <example>
The following example shows how to get the <c>PlaceMonitor</c> and use 
it to get current place.
<code lang="C#">
PlaceMonitor placeMonitor = await PlaceMonitor.GetDefaultAsync();
Place place = await placeMonitor.GetCurrentPlaceAsync();
</code></example>
        </member>
        <member name="T:Lumia.Sense.PlaceChangedEventHandler">
            <summary>
Delegate type of the <c>PlaceChanged</c> event handler of <c>PlaceMonitor</c>.
</summary>
            <param name="source">event source</param>
            <param name="value">event value</param>
        </member>
        <member name="M:Lumia.Sense.PlaceChange.#ctor(System.UInt32,Lumia.Sense.PlaceKind,Lumia.Sense.PlaceState,Windows.Foundation.DateTime)">
            <summary>
Constructor
</summary>
            <param name="id">place id</param>
            <param name="kind">Place kind</param>
            <param name="newState">new place state</param>
            <param name="timestamp">time stamp</param>
        </member>
        <member name="P:Lumia.Sense.PlaceChange.Timestamp">
            <summary>
Gets the time when the event occured.
</summary>
            <returns> The time when the event occured.</returns>
        </member>
        <member name="P:Lumia.Sense.PlaceChange.NewState">
            <summary>
Gets the new state of the place.
</summary>
            <returns>New state of the place</returns>
        </member>
        <member name="P:Lumia.Sense.PlaceChange.Kind">
            <summary>
Gets the type or kind of the place.
</summary>
            <returns>Place type or kind</returns>
        </member>
        <member name="P:Lumia.Sense.PlaceChange.Id">
            <summary>
Gets the unique id of the place.
</summary>
            <returns>Unique place id</returns>
        </member>
        <member name="T:Lumia.Sense.PlaceChange">
            <summary>
Contains information about change to a known place or to the device's 
location with respect to a place.
</summary>
        </member>
        <member name="M:Lumia.Sense.Place.#ctor(System.UInt32,Lumia.Sense.PlaceKind,Windows.Devices.Geolocation.BasicGeoposition,System.Double,Windows.Foundation.DateTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Windows.Foundation.TimeSpan!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructor
</summary>
            <param name="id">Place id</param>
            <param name="kind">Place kind</param>
            <param name="position">Place location</param>
            <param name="radius">Place radius</param>
            <param name="timestamp">Timestamp</param>
            <param name="lengthOfStay">Length of stay</param>
        </member>
        <member name="P:Lumia.Sense.Place.LengthOfStay">
            <summary>Time how long the device stayed in this location.</summary>
            <remarks>The value is zero if the length could not be determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.Place.Timestamp">
            <summary> The time when the place has beed entered.</summary>
        </member>
        <member name="P:Lumia.Sense.Place.Radius">
            <summary>The radius of the circular area of the place centered at <see cref="P:Lumia.Sense.Place.Position" /> in meters.</summary>
            <remarks>The value is <c>NAN</c> if the radius could not be determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.Place.Position">
            <summary>Geographic position of the place.</summary>
            <remarks>The Altitude field is <c>NAN</c> if the altitude could not be determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.Place.Kind">
            <summary>Type or kind of the place.</summary>
        </member>
        <member name="P:Lumia.Sense.Place.Id">
            <summary>Unique identifier of the place.</summary>
        </member>
        <member name="T:Lumia.Sense.Place">
            <summary>
Contains information about a known place.
</summary>
        </member>
        <member name="T:Lumia.Sense.PlaceKind">
            <summary>
Indicates the type or kind of a place.
</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceKind.Frequent">
            <summary>Other frequently visited place.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceKind.Work">
            <summary>Place of work.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceKind.Home">
            <summary>Home or home-like place.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceKind.None">
            <summary>No value/unknown place.</summary>
        </member>
        <member name="T:Lumia.Sense.PlaceState">
            <summary>
Indicates the current state of a place.
</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceState.Removed">
            <summary>Known place was removed.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceState.Exited">
            <summary>The device has exited a known place.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceState.Entered">
            <summary>The device has entered a known place.</summary>
        </member>
        <member name="F:Lumia.Sense.PlaceState.None">
            <summary>No value or an undefined state.</summary>
        </member>
        <member name="D:Lumia.Sense.PlaceId">
            <summary>
Place id type definition.
</summary>
        </member>
        <member name="M:Lumia.Sense.IStepCounter.GetStepCountAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the step count at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>Please note that this method only returns data from history which is recorded at five minute intervals.
Therefore the data can be up to five minutes old. If you need to get the current reading, use <see cref="M:Lumia.Sense.IStepCounter.GetCurrentReadingAsync" />.</paragraph></remarks>
            <param name="timestamp">time to get the step count for</param>
            <returns>Step count at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <c>StepCounter</c> and fetch steps from two hours ago.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading steps = await stepCounter.GetStepCountAtAsync( DateTime.Now.AddHours( -2 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IStepCounter.GetStepCountHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of step counts during given time period. Data granularity is usually around five minutes.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <returns>Step count history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, <see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>Please note that this method only returns data from history which is recorded at five minute intervals.
Therefore the data can be up to five minutes old. If you need to get the current reading, use <see cref="M:Lumia.Sense.IStepCounter.GetCurrentReadingAsync" />.</paragraph><paragraph>If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the step count at the start of the period 
before the first actual event within that period.</paragraph></remarks>
            <example>
The following example shows how to get the <c>StepCounter</c> and fetch steps from past hour.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
IList&lt;StepCounterReading&gt; steps = await stepCounter.GetStepCountHistoryAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IStepCounter.GetCurrentReadingAsync">
            <summary>
Gets the current reading.
</summary>
            <returns>
The current reading of the sensor.
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained currently.
</remarks>
            <example>
The following example shows how to get the <c>StepCounter</c> and fetch a current
number of steps.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading currentSteps = await stepCounter.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="T:Lumia.Sense.IStepCounter">
            <summary>
Represents a step counter sensor.
</summary>
            <remarks>
This sensor returns the user's step count information.
</remarks>
            <example>
The following example shows how to get the <c>StepCounter</c> and fetch a current
number of steps.
<code lang="C#">
StepCounter stepCounter = await StepCounter.GetDefaultAsync();
StepCounterReading currentSteps = await stepCounter.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.StepCounterReading.#ctor(System.UInt32,Windows.Foundation.TimeSpan,System.UInt32,Windows.Foundation.TimeSpan,Windows.Foundation.DateTime)">
            <summary>
Constructor
</summary>
            <param name="walkingStepCount">walking step count</param>
            <param name="walkTime">walk time</param>
            <param name="runningStepCount">running step count</param>
            <param name="runTime">run time</param>
            <param name="timestamp">timestamp</param>
        </member>
        <member name="P:Lumia.Sense.StepCounterReading.Timestamp">
            <summary>
Gets the creation time of the sensor reading.
</summary>
            <returns>timestamp</returns>
        </member>
        <member name="P:Lumia.Sense.StepCounterReading.RunTime">
            <summary>
Gets the time spent running since the motion data was enabled.
</summary>
            <returns>total running duration</returns>
        </member>
        <member name="P:Lumia.Sense.StepCounterReading.RunningStepCount">
            <summary>
Gets the number of running steps taken since the motion data was enabled.
</summary>
            <returns>running step count</returns>
        </member>
        <member name="P:Lumia.Sense.StepCounterReading.WalkTime">
            <summary>
Gets the time spent walking since the motion data was enabled.
</summary>
            <returns>total walk duration</returns>
        </member>
        <member name="P:Lumia.Sense.StepCounterReading.WalkingStepCount">
            <summary>
Gets the number of walking steps taken since the motion data was enabled.
</summary>
            <returns>walking step count</returns>
        </member>
        <member name="T:Lumia.Sense.StepCounterReading">
            <summary>
Represents a reading of the <c>StepCounter</c>.
</summary>
        </member>
        <member name="M:Lumia.Sense.IActivityMonitor.GetActivityAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the device activity at given time.
</summary>
            <param name="timestamp">Time stamp</param>
            <returns>Activity at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <example>
The following example shows how to get the <c>ActivityMonitor</c> and use 
it to get activity from one hour ago.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading activity = await activityMonitor.GetActivityAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IActivityMonitor.GetActivityHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of activities occured during given time period.
</summary>
            <param name="periodFrom">Time period start</param>
            <param name="span">Time period length</param>
            <returns>Activity history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />,  
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>The returned list includes all activity monitor readings within the given time pediod.
If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the activity state of the device at the start of the period 
before the first actual activity event within that period.</paragraph></remarks>
            <example>
The following example shows how to get the <c>ActivityMonitor</c> and use 
it to get activity history from past 24 hours.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
IList&lt;ActivityMonitorReading&gt; activities = await activityMonitor.GetActivityHistoryAsync( DateTime.Now.AddDays( -1 ), TimeSpan.FromDays( 1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IActivityMonitor.GetSupportedActivitiesAsync">
            <summary>
Returns activities that can be detected by this device.
</summary>
            <returns>Activities that can be detected by this device</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <example>
The following example shows how to get the <c>ActivityMonitor</c> and use 
it to get supported activities.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
Activities activities = await activityMonitor.GetSupportedActivitiesAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.IActivityMonitor.GetCurrentReadingAsync">
            <summary>
Gets the current activity
</summary>
            <returns>Current activity</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained.
</remarks>
            <example>
The following example shows how to get the <c>ActivityMonitor</c> and use 
it to get current activity.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading reading = await activityMonitor.GetCurrentReadingAsync();
</code></example>
        </member>
        <member name="P:Lumia.Sense.IActivityMonitor.SubscribedActivities">
            <summary>
Activities the client is interested in.
</summary>
            <remarks>
                <paragraph>By default, no activities will be included in the mask. In order 
for the client to receive activity notifications it must first set the activities 
it is interested in. It is recommended to keep the mask minimal in order to optimize 
resource usage during activity monitoring.</paragraph>
            </remarks>
        </member>
        <member name="E:Lumia.Sense.IActivityMonitor.ReadingChanged">
            <summary>
Occurs each time one of the activity modes specified in <see cref="P:Lumia.Sense.IActivityMonitor.SubscribedActivities" /> starts or ends.
</summary>
            <remarks>
An application may register a handler for this event to be notified of activity changes as 
an alternative to actively polling the values using <see cref="M:Lumia.Sense.IActivityMonitor.GetCurrentReadingAsync" />.
</remarks>
            <example>
The following example shows how to register for running and walking activity events.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
activityMonitor.SubscribedActivities = Activities.Running | Activities.Walking;
activityMonitor.ReadingChanged += activityMonitor_ReadingChanged;
</code>
Here is the handler for activity change events.
<code lang="C#">
private void activityMonitor_ReadingChanged( IActivityMonitor source, ActivityMonitorReading value )
{
    // Handle activity change event here
}
</code></example>
        </member>
        <member name="T:Lumia.Sense.ActivityReadingChangedEventHandler">
            <summary>
Delegate type the <c>ReadingChanged</c> event handler of <c>ActivityMonitor</c>.
</summary>
            <param name="source">event source</param>
            <param name="value">activity reading</param>
        </member>
        <member name="T:Lumia.Sense.IActivityMonitor">

Forward declaration for Activity monitor

<summary>
Represents an activity state monitor sensor.
</summary><remarks>
This sensor returns the user's activity state values derived from
various sources of sensor and contextual information within the device.
</remarks><example>
The following example shows how to get the <c>ActivityMonitor</c> and use 
it to get current activity.
<code lang="C#">
ActivityMonitor activityMonitor = await ActivityMonitor.GetDefaultAsync();
ActivityMonitorReading reading = await activityMonitor.GetCurrentReadingAsync();
</code></example></member>
        <member name="M:Lumia.Sense.ActivityMonitorReading.#ctor(Lumia.Sense.Activity,Windows.Foundation.DateTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructor
</summary>
            <param name="mode">Activity</param>
            <param name="timestamp">Time stamp</param>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitorReading.Timestamp">
            <summary>
Gets the time at which the sensor reported the reading.
</summary>
            <remarks>As the activity mode is derived computationally from other
available information, the value does not correspond clearly to a concrete
event in the physical world. Instead, it reflects the point in time when 
the underlying algorithm determined that the activity mode changed.
</remarks>
        </member>
        <member name="P:Lumia.Sense.ActivityMonitorReading.Mode">
            <summary>
Gets the activity.
</summary>
        </member>
        <member name="T:Lumia.Sense.ActivityMonitorReading">
            <summary>
Supported device placements.
</summary>
            <remarks>
The device placement detection may be included as an additional
information with activity detection notifications.
</remarks>
            <summary>Represents a reading of the <c>ActivityMonitor</c>.</summary>
        </member>
        <member name="T:Lumia.Sense.Activity">
            <summary>
Single activity
</summary>
            <remarks>
The activity hierarchy is as follows:
<code>
   None
   Other
       Idle
       Stationary
       Moving
           MovingOnFoot
		       Walking
               Running
		   MovingInVehicle 
</code><c>None</c> means no value is set, activity could not be
identified.
<paragraph><c>Other</c> activity includes all other activities. All activities not
not explicitly subscribed to with <c>SubscribedActivities</c> are mapped to
<c>Other</c>.
</paragraph></remarks>
        </member>
        <member name="F:Lumia.Sense.Activity.MovingInVehicle">
            <summary>
Moving in vehicle
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Running">
            <summary>
Running
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Walking">
            <summary>
Walking
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.MovingOnFoot">
            <summary>
Moving on foot
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Stationary">
            <summary>
Stationary
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Moving">
            <summary>
Moving
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Idle">
            <summary>
Idle
</summary>
        </member>
        <member name="F:Lumia.Sense.Activity.Other">
            <summary>
Unknown/other activity
</summary>
            <remarks>
                <c>Other</c> activity includes all other activities. All activities not
not explicitly subscribed to with <c>SubscribedActivities</c> are mapped to
<c>Other</c>.
</remarks>
        </member>
        <member name="F:Lumia.Sense.Activity.None">
            <summary>
No activity
</summary>
            <remarks>
                <c>None</c> means no value is set, i.e. activity could not be identified.
</remarks>
        </member>
        <member name="T:Lumia.Sense.Activities">
            <summary>
Subscribed activities 
</summary>
            <remarks>
The activity hierarchy is as follows:
<code>
   None
   Other
       Idle
       Stationary
       Moving
           MovingOnFoot
		       Walking
               Running
		   MovingInVehicle 
</code><c>None</c> means no value is set, activity could not be
identified.
<paragraph><c>Other</c> activity includes all other activities. All activities not
not explicitly subscribed to with <c>SubscribedActivities</c> are mapped to
<c>Other</c>.
</paragraph></remarks>
        </member>
        <member name="F:&lt;unknown type&gt;.Any">
            <summary>
Combination of all activities
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.MovingInVehicle">
            <summary>
Moving in vehicle
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Running">
            <summary>
Running
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Walking">
            <summary>
Walking
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.MovingOnFoot">
            <summary>
Moving on foot
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Stationary">
            <summary>
Stationary
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Moving">
            <summary>
Moving
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Idle">
            <summary>
Idle
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Other">
            <summary>
Unknown/other activity
</summary>
            <remarks>
                <c>Other</c> activity includes all other activities. All activities not
not explicitly subscribed to with <c>SubscribedActivities</c> are mapped to
<c>Other</c>.
</remarks>
        </member>
        <member name="F:&lt;unknown type&gt;.None">
            <summary>
No activity
</summary>
            <remarks>
                <c>None</c> means no value is set, i.e. activity could not be identified.
</remarks>
        </member>
        <member name="M:Lumia.Sense.IRouteTracker.GetPointAtAsync(Windows.Foundation.DateTime)">
            <summary>
Returns the location of the device at given time.
</summary>
            <param name="timestamp">Time stamp</param>
            <returns>Device location at given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />, 
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, <see cref="F:Lumia.Sense.SenseError.NotFound" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available data extends only up to last 10 days. The return value 
is <c>null</c> in case route point is not available for the given time.
</remarks>
            <example>
The following example shows how to get the <c>RouteTracker</c> and fetch a route
point from one hour ago.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
RoutePoint RoutePoint = await routeTracker.GetPointAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.IRouteTracker.GetRouteAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns the route the device moved during the given time period.
</summary>
            <param name="periodFrom">Start time</param>
            <param name="span">Time span</param>
            <returns>Route for the given time period</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.InvalidParameter" />,  
<see cref="F:Lumia.Sense.SenseError.SensorDeactivated" />, <see cref="F:Lumia.Sense.SenseError.GeneralFailure" />, 
<see cref="F:Lumia.Sense.SenseError.SenseDisabled" />, <see cref="F:Lumia.Sense.SenseError.LocationDisabled" /></exception>
            <remarks>
The available route data extends only up to last 10 days.
</remarks>
            <example>
The following example shows how to get the <c>RouteTracker</c> and fetch a route
history from one hour ago to now.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
IList&lt;RoutePoint&gt; routePoints = await routeTracker.GetRouteAsync( DateTime.Now.AddHours( -1 ), TimeSpan.FromHours( 1 ) );
</code></example>
        </member>
        <member name="T:Lumia.Sense.IRouteTracker">
            <summary>
Represents a monitor that identifies and maintains a list of geographic places
visited by the device.
</summary>
            <remarks>
Route points are collected passively, i.e. it won't actively track user's location with GPS,
accuracy of route points reflects the used positioning technology.
</remarks>
            <example>
The following example shows how to get the <c>RouteTracker</c> and fetch a route
point from one hour ago.
<code lang="C#">
RouteTracker routeTracker = await RouteTracker.GetDefaultAsync();
RoutePoint routePoint = await routeTracker.GetPointAtAsync( DateTime.Now.AddHours( -1 ) );
</code></example>
        </member>
        <member name="M:Lumia.Sense.RoutePoint.#ctor(Lumia.Sense.RoutePoint)">
            <summary>
Constructor
</summary>
            <param name="routePoint">Route point</param>
        </member>
        <member name="M:Lumia.Sense.RoutePoint.#ctor(Windows.Devices.Geolocation.BasicGeoposition,System.Double,System.Double,Windows.Foundation.TimeSpan,Windows.Foundation.DateTime)">
            <summary>
Constructor
</summary>
            <param name="position">Position</param>
            <param name="heading">Heading</param>
            <param name="radius">Radius</param>
            <param name="lengthOfStay">Length of stay</param>
            <param name="timestamp">Time stamp</param>
        </member>
        <member name="P:Lumia.Sense.RoutePoint.Radius">
            <summary>The estimated radius of a circular area around the location  
which reflects the used positioning technology.</summary>
            <remarks>The value is NAN if the radius could not be determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.RoutePoint.LengthOfStay">
            <summary>Time how long the device stayed at this point.</summary>
            <remarks>The value is zero if the length of stay in the location could not be
determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.RoutePoint.Timestamp">
            <summary>Time of entry to the location.</summary>
        </member>
        <member name="P:Lumia.Sense.RoutePoint.Position">
            <summary>Geographic position of the route point.</summary>
            <remarks>The Altitude field is <c>NAN</c> if the altitude could not be determined.</remarks>
        </member>
        <member name="P:Lumia.Sense.RoutePoint.Heading">
            <summary>The current heading between 0.0 and 360.0 in degrees relative to
true north.</summary>
            <remarks>The value is <c>NAN</c> if the heading could not be determined.</remarks>
        </member>
        <member name="T:Lumia.Sense.RoutePoint">
            <summary>
Represents a point within a route the device has been located in.
</summary>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.DoGetApiVersion(Lumia.Sense.ApiVersionInfo)">
            <summary>
Returns Sense API version information
</summary>
            <param name="versionInfo">Upon success will contain version info</param>
            <returns>Return code</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.DoGetApiState(Lumia.Sense.ApiState)">
            <summary>
Returns Sense and Location API state
</summary>
            <param name="state">Upon success will contain the API state</param>
            <returns>Return code</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.IsSupportedAsync(Lumia.Sense.SensorType)">
            <summary>
Returns whether the given sensor is supported by the device or not.
</summary>
            <param name="type">Sensor type</param>
            <returns>
                <c>true</c> if the sensor is supported, <c>false</c>otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.ValidateSensor(HIDMessage.SenseSensorType)">
            <summary>
Check to ensure that the sensor is supported and can be used (Motion data collection and location are enabled
if required by the sensor).
</summary>
            <param name="type">sensor type</param>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.LoadJsonAsync(System.String)">
            <summary>
Loads Json object from a file in application's installation directory
</summary>
            <param name="filename">Json file name</param>
            <returns>Loaded Json object</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example loads Json object from application's installation directory
<code>
JsonObject jsonData = await SenseHelper.LoadJsonAsync("json.txt");
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)">
            <summary>
Returns Sense error matching the given HResult code from an exception
</summary>
            <param name="hresult">HResult code received from exception thrown by Sense API</param>
            <returns>Sense error code</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.LaunchLocationSettingsAsync">
            <summary>
Launches Location settings
</summary>
            <remarks>
An alternative way of doing this is to utilize the "ms-settings-location:" URI launch schema, i.e.
<code>await Windows.System.Launcher.LaunchUriAsync(new Uri("ms-settings-location:"));</code></remarks>
            <returns>true if settings was launched, false otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.LaunchSenseSettingsAsync">
            <summary>
Launches Sense settings
</summary>
            <remarks>
An alternative way of doing this is to utilize the "sensesettings:" URI launch schema, i.e.
<code>await Windows.System.Launcher.LaunchUriAsync(new Uri("sensesettings:"));</code></remarks>
            <returns>true if settings was launched, false otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.GetApiVersionAsync">
            <summary>
Returns Sense API version information
</summary>
            <returns>Object containing Sense API version details</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.SenseHelper.GetApiStateAsync">
            <summary>
Returns Sense and Location API state
</summary>
            <returns>Object containing Sense and Location API state</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: 
<see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="T:Lumia.Sense.SenseHelper">
            <summary>
Helper class providing miscellaneous Sense helper methods
</summary>
        </member>
        <member name="P:Lumia.Sense.ApiVersionInfo.ServiceVersion">
            <summary>Service version.</summary>
        </member>
        <member name="M:Lumia.Sense.ApiVersionInfo.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ApiVersionInfo.#ctor(System.UInt32,System.String)">
            <summary>
Constructor
</summary>
            <param name="version">API version.</param>
            <param name="serviceVersion">Service version.</param>
        </member>
        <member name="P:Lumia.Sense.ApiVersionInfo.APIVersion">
            <summary>API version.</summary>
        </member>
        <member name="T:Lumia.Sense.ApiVersionInfo">
            <summary>
Sense API version info
</summary>
        </member>
        <member name="M:Lumia.Sense.ApiState.#ctor">
            <summary>
Constructor
</summary>
        </member>
        <member name="M:Lumia.Sense.ApiState.#ctor(System.Boolean,System.Boolean)">
            <summary>
Constructor
</summary>
            <param name="locationEnabled">
                <c>true</c> if the location setting of the phone is enabled, <c>false</c> otherwise.</param>
            <param name="senseEnabled">
                <c>true</c> if the motion data setting of the phone is enabled, <c>false</c> otherwise.</param>
        </member>
        <member name="P:Lumia.Sense.ApiState.SenseEnabled">
            <summary>
                <c>true</c> if the motion data setting of the phone is enabled, <c>false</c> otherwise.</summary>
        </member>
        <member name="P:Lumia.Sense.ApiState.LocationEnabled">
            <summary>
                <c>true</c> if the location setting of the phone is enabled, <c>false</c> otherwise.</summary>
        </member>
        <member name="T:Lumia.Sense.ApiState">
            <summary>
Sense and location API state
</summary>
        </member>
        <member name="T:Lumia.Sense.SenseError">
            <summary>
Sense error codes
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.IncompatibleSDK">
            <summary>
Incompatible SDK. Sense platform in the device is incompatible with the SDK version.
Please make sure to update to the latest SDK version.
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.SensorDeactivated">
            <summary>
Sensor is deactivated. You need to reactivate it by calling <c>ActivateAsync()</c></summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.SenseNotAvailable">
            <summary>
SensorCore SDK is not supported on this device
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.SensorNotAvailable">
            <summary>
Such sensor is not available on this device
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.Busy">
            <summary>
The component is busy, try again later
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.InvalidParameter">
            <summary>
Invalid input parameter(s)
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.LocationDisabled">
            <summary>
Location is disabled by the user from the Location settings
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.SenseDisabled">
            <summary>
User has disabled motion data collection from the Motion data setttings
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.NotFound">
            <summary>
Item not found. There was no item matching the given criteria found.
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseError.GeneralFailure">
            <summary>
General failure
</summary>
        </member>
        <member name="M:Lumia.Sense.ISensor.DeactivateAsync">
            <summary>
Close the communication with underlying sensor, this explicitly closes the communication channel.
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="M:Lumia.Sense.ISensor.ActivateAsync">
            <summary>
Reestablish the communication channel with underlying sensor, if not already exists
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="P:Lumia.Sense.ISensor.Type">
            <summary>
Gets the sensor type.
</summary>
            <returns>sensor type</returns>
        </member>
        <member name="T:Lumia.Sense.ISensor">
            <summary>
Base class for all SensorCore SDK sensors
</summary>
        </member>
        <member name="T:Lumia.Sense.SensorType">
            <summary>
Indicates the type of the sensor.
</summary>
        </member>
        <member name="F:Lumia.Sense.SensorType.RouteTracker">
            <summary> Route tracker </summary>
        </member>
        <member name="F:Lumia.Sense.SensorType.PlaceMonitor">
            <summary> Place monitor </summary>
        </member>
        <member name="F:Lumia.Sense.SensorType.StepCounter">
            <summary> Step counter </summary>
        </member>
        <member name="F:Lumia.Sense.SensorType.ActivityMonitor">
            <summary> Activity monitor </summary>
        </member>
        <member name="M:Lumia.Internal.Json.CreateStepCounterCurrentReadings(Windows.Data.Json.JsonObject)">
            <summary>
Creates list of step counter current readings from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>List of step counter current readings</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateStepCounterDataPollReadings(Windows.Data.Json.JsonObject)">
            <summary>
Creates list of step counter data poll readings from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>List of step counter data poll readings</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateRoute(Windows.Data.Json.JsonObject)">
            <summary>
Creates route from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>Route points</returns>
        </member>
        <member name="M:Lumia.Internal.Json.GetActivityMonitorSupportedActivities(Windows.Data.Json.JsonObject)">
            <summary>
Returns supported activity monitor activities from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>Supported activity monitor activities</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateActivityMonitorReadings(Windows.Data.Json.JsonObject)">
            <summary>
Creates list of activity monitor readings from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>List of activity monitor readings</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreatePlaceChangesHistory(Windows.Data.Json.JsonObject)">
            <summary>
Creates place changes history from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>Place changes history</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreatePlaceHistory(Windows.Data.Json.JsonObject)">
            <summary>
Creates place history from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>Place history</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateKnownPlaces(Windows.Data.Json.JsonObject)">
            <summary>
Creates list of known places from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>List of known places</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateRoutePoint(Windows.Data.Json.JsonObject)">
            <summary>
Creates route point from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>New route point</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateActivityMonitorReading(Windows.Data.Json.JsonObject)">
            <summary>
Creates activity monitor reading from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>New activity monitor reading</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateStepCounterReading(Windows.Data.Json.JsonObject)">
            <summary>
Creates step counter reading from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>New step counter reading</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreatePlaceChange(Windows.Data.Json.JsonObject)">
            <summary>
Creates place change from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>New place change</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreatePlace(Windows.Data.Json.JsonObject)">
            <summary>
Creates place from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>New place</returns>
        </member>
        <member name="M:Lumia.Internal.Json.CreateRecording(Windows.Data.Json.JsonObject)">
            <summary>
Creates sensor recording from given Json object
</summary>
            <param name="data">Json data</param>
            <returns>Sensor recording</returns>
        </member>
        <member name="M:Lumia.Internal.Json.ReplaceRecordingMetadata(Windows.Data.Json.JsonObject,Lumia.Sense.SensorType,Windows.Foundation.DateTime,Windows.Foundation.TimeSpan,System.String)">
            <summary>
Adds metadata to the given recording
</summary>
            <remarks>This method will replace any existing metadata</remarks>
            <param name="recording">Recording data</param>
            <param name="type">Recorded sensor type</param>
            <param name="startTime">Date of recording</param>
            <param name="duration">Recording duration</param>
            <param name="description">Description of the recording</param>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Windows.Foundation.Collections.IVector`1{Lumia.Sense.RoutePoint^})">
            <summary>
Returns Json representation of the given route
</summary>
            <param name="route">Route</param>
            <returns>Json representation of the given route</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Windows.Foundation.Collections.IVector`1{Lumia.Sense.ActivityMonitorReading^},&lt;unknown type&gt;)">
            <summary>
Returns Json representation of the given activity monitor readings
</summary>
            <param name="readings">List of activity monitor readings</param>
            <param name="supportedActivities">Supported activities</param>
            <returns>Json representation of the given activity monitor readings</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Windows.Foundation.Collections.IVector`1{Lumia.Sense.StepCounterReading^},Windows.Foundation.Collections.IVector`1{Lumia.Sense.StepCounterReading^})">
            <summary>
Returns Json representation of the given step counter readings
</summary>
            <param name="dataPollHistory">List of data poll readings</param>
            <param name="currentReadingHistory">List of current readings</param>
            <returns>Json representation of the given step counter readings</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Windows.Foundation.Collections.IVector`1{Lumia.Sense.Place^},Windows.Foundation.Collections.IVector`1{Lumia.Sense.Place^},Windows.Foundation.Collections.IVector`1{Lumia.Sense.PlaceChange^})">
            <summary>
Returns Json representation of the given places data
</summary>
            <param name="knownPlaces">Known places at the start of recording</param>
            <param name="placeHistory">Place history</param>
            <param name="placeChanges">Place change events</param>
            <returns>Json representation of the given data</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Lumia.Sense.RoutePoint)">
            <summary>
Returns Json representation of the given route point
</summary>
            <param name="point">Route point</param>
            <returns>Json representation of the given route point</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Lumia.Sense.ActivityMonitorReading)">
            <summary>
Returns Json representation of the given activity monitor reading
</summary>
            <param name="reading">Activity monitor reading</param>
            <returns>Json representation of the given activity monitor reading</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Lumia.Sense.StepCounterReading)">
            <summary>
Returns Json representation of the given step counter reading
</summary>
            <param name="reading">Step counter reading</param>
            <returns>Json representation of the given step counter reading</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Lumia.Sense.PlaceChange)">
            <summary>
Returns Json representation of the given place change
</summary>
            <param name="change">Place change</param>
            <returns>Json representation of the given place change</returns>
        </member>
        <member name="M:Lumia.Internal.Json.AsJson(Lumia.Sense.Place)">
            <summary>
Returns Json representation of the given place
</summary>
            <param name="place">Place</param>
            <returns>Json representation of the given place</returns>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_fLoop">
            <summary> Should simulator loop events </summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_recordingDuration">
            <summary> Recording duration </summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_recordingStart">
            <summary> Recording start timestamp </summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_simulationStart">
            <summary> Simulation start timestamp </summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_currentSteps">
            <summary> Simulated current steps </summary>
        </member>
        <member name="F:Lumia.Sense.StepCounterSimulator.m_steps">
            <summary> Simulated history steps </summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.#ctor(Lumia.Sense.SenseRecording,System.UInt64)">
            <summary>
Constructor
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Start time for simulation.</param>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.DeactivateAsync">
            <summary>
Closes the connection to sensor
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.ActivateAsync">
            <summary>
Re-establishes connection to sensor, if not already available
</summary>
            <returns>
Returns an IAsyncAction object that is used to control the asynchronous operation.
</returns>
        </member>
        <member name="P:Lumia.Sense.StepCounterSimulator.Type">
            <summary>
The sensor type.
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.Dispose">
            <summary>
Destructor
</summary>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetStepCountAtAsync(Windows.Foundation.DateTime)">
            <summary>
Gets the step count at given time.
</summary>
            <remarks>
The available data extends only up to the last 10 days.
</remarks>
            <param name="timestamp">time to get the step count for</param>
            <returns>Step count at the given time</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetStepCountHistoryAsync(Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Returns time ordered list of step counts during given time period. Data granularity is usually around five minutes.
</summary>
            <param name="startTime">start time</param>
            <param name="span">time span</param>
            <remarks>
The available data extends only up to the last 10 days.
<paragraph>The returned list includes step counts within the given time pediod.
If available, the result list begins with the last entry before the beginning of the given period. 
This enables an application to determine the step count at the start of the period 
before the first actual event within that period.</paragraph></remarks>
            <returns>Step count history</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetCurrentReadingAsync">
            <summary>
Gets the current reading.
</summary>
            <returns>
The current reading of the sensor.
</returns>
            <remarks>
The return value may be <c>null</c> in case reading cannot be obtained currently.
</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording,Windows.Foundation.DateTime)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <param name="startTime">Start time for simulation.</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetDefaultAsync(Lumia.Sense.SenseRecording)">
            <summary>
Gets the default implementation.
</summary>
            <param name="recording">Sensor recording</param>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="M:Lumia.Sense.StepCounterSimulator.GetDefaultAsync">
            <summary>
Gets the default implementation.
</summary>
            <returns>
The default implementation
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
        </member>
        <member name="T:Lumia.Sense.StepCounterSimulator">
            <summary>
Represents a step counter sensor.
</summary>
            <remarks>
This sensor returns the user's step count information.
</remarks>
        </member>
        <member name="F:Lumia.Sense.SenseRecorder.m_senseRecorder">
            <summary>Recorder implementation</summary>
        </member>
        <member name="M:Lumia.Sense.SenseRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to get the recorded data.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
await _recorder.StartAsync();
 ...
await _recorder.StopAsync();
SenseRecording recording = _recorder.GetRecording();
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecorder.StopAsync">
            <summary>
Stops recording
</summary>
            <returns>Asynchronous task</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to stop recording a sensor.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
await _recorder.StartAsync();
 ...
await _recorder.StopAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecorder.StartAsync">
            <summary>
Starts recording
</summary>
            <returns>Asynchronous task</returns>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to start recording a sensor.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
await _recorder.StartAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecorder.#ctor(Lumia.Sense.ISensor)">
            <summary>
Constructor
</summary>
            <param name="sensor">sensor to be recorded</param>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to instantiate the Sense recorder.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
</code></example>
        </member>
        <member name="P:Lumia.Sense.SenseRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="T:Lumia.Sense.SenseRecorder">
            <summary>
Utility for recording sensor data
<paragraph>
You can use <see cref="T:Lumia.Sense.SenseRecorder" /> to record data from a sensor for storage or playing back at 
a later date.
</paragraph></summary>
            <example>
The following example shows how to instantiate the <c>SenseRecorder</c>, record Step counter sensor data
and prompt the user to share or save the recording into a file in Documents folder.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
await _recorder.StartAsync();
 ...
await _recorder.StopAsync();
SenseRecording recording = _recorder.GetRecording();
await recording.SaveAsync();
</code></example>
        </member>
        <member name="M:Lumia.Sense.ISenseRecorder.IsRecording">
            <summary>
Returns whether the recorder is currently recording or not.
</summary>
            <returns>
                <c>true</c> if the recorder is currently recording, <c>false</c> otherwise</returns>
        </member>
        <member name="M:Lumia.Sense.ISenseRecorder.GetRecording">
            <summary>
Returns the recording
</summary>
            <returns>
Sensor recording
</returns>
        </member>
        <member name="M:Lumia.Sense.ISenseRecorder.StopAsync">
            <summary>
Stops recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="M:Lumia.Sense.ISenseRecorder.StartAsync">
            <summary>
Starts recording
</summary>
            <returns>Asynchronous task</returns>
        </member>
        <member name="T:Lumia.Sense.ISenseRecorder">
            <summary>
Recorder interface that each sensor implements
</summary>
        </member>
        <member name="M:Lumia.Sense.RecordingInfo.#ctor(Lumia.Sense.SensorType,System.String,Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Constructor
</summary>
            <param name="type">Recorded sensor type</param>
            <param name="description">Description of recording</param>
            <param name="startTime">Start time of recording</param>
            <param name="duration">Recording duration</param>
        </member>
        <member name="P:Lumia.Sense.RecordingInfo.Duration">
            <summary>
Recording duration
</summary>
        </member>
        <member name="P:Lumia.Sense.RecordingInfo.StartTime">
            <summary>
Recording start time
</summary>
        </member>
        <member name="P:Lumia.Sense.RecordingInfo.Description">
            <summary>
Description of recording
</summary>
        </member>
        <member name="P:Lumia.Sense.RecordingInfo.Type">
            <summary>
Recorded sensor type
</summary>
        </member>
        <member name="T:Lumia.Sense.RecordingInfo">
            <summary>
Sensor recording metadata
</summary>
        </member>
        <member name="F:Lumia.Sense.SenseRecording.m_duration">
            <summary>Duration</summary>
        </member>
        <member name="F:Lumia.Sense.SenseRecording.m_startTime">
            <summary>Start time</summary>
        </member>
        <member name="F:Lumia.Sense.SenseRecording.m_recording">
            <summary>Recorded sensor data</summary>
        </member>
        <member name="F:Lumia.Sense.SenseRecording.m_type">
            <summary>Recorded sensor type</summary>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.#ctor(Lumia.Sense.SensorType,Windows.Data.Json.JsonObject,Windows.Foundation.DateTime,Windows.Foundation.TimeSpan)">
            <summary>
Constructor
</summary>
            <param name="type">Recorded sensor type</param>
            <param name="recording">Recording data</param>
            <param name="startTime">Date of recording</param>
            <param name="duration">Duration of recording</param>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.LoadFromText(System.String,Windows.Storage.Streams.UnicodeEncoding)">
            <summary>
Loads <see cref="T:Lumia.Sense.SenseRecording" /> from given text string.
</summary>
            <param name="recordingData">Recording data</param>
            <param name="encoding">Content encoding</param>
            <returns>Loaded recording</returns>
            <remarks>If you have saved the recording using the content viewer launched by <see cref="M:Lumia.Sense.SenseRecording.SaveAsync" />, the content will be 
using <c>UTF-16 LE</c> encoding.</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example loads sensor recording from given text (using UTF-8 encoding)
<code>
SenseRecording recording = await SenseRecording.LoadFromText( recordingData, UnicodeEncoding::Utf8 );
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.LoadFromText(System.String)">
            <summary>
Loads <see cref="T:Lumia.Sense.SenseRecording" /> from given text string.
</summary>
            <param name="recordingData">Recording data</param>
            <param name="encoding">Content encoding</param>
            <returns>Loaded recording</returns>
            <remarks>This method expects the content to be saved using <c>UTF-16 LE</c> encoding. If you have saved the recording using
the content viewer launched by <see cref="M:Lumia.Sense.SenseRecording.SaveAsync" />, the content will be using <c>UTF-16 LE</c> encoding.</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example loads sensor recording from given text
<code>
SenseRecording recording = await SenseRecording.LoadFromText( recordingData );
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.LoadFromFileAsync(System.String,Windows.Storage.Streams.UnicodeEncoding)">
            <summary>
Loads <see cref="T:Lumia.Sense.SenseRecording" /> from a file in application's installation directory
</summary>
            <param name="filename">Recoding file name</param>
            <param name="encoding">Content encoding</param>
            <returns>Loaded recording</returns>
            <remarks>If you have saved the recording using the content viewer launched by <see cref="M:Lumia.Sense.SenseRecording.SaveAsync" />, the content will be 
using <c>UTF-16 LE</c> encoding.</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example loads sensor recording from application's installation directory (using UTF-16 LE encoding)
<code>
SenseRecording recording = await SenseRecording.LoadFromFileAsync( "json.txt", UnicodeEncoding::Utf16LE );
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.LoadFromFileAsync(System.String)">
            <summary>
Loads <see cref="T:Lumia.Sense.SenseRecording" /> from a file in application's installation directory.
</summary>
            <param name="filename">Recoding file name</param>
            <returns>Loaded recording</returns>
            <remarks>This method expects the content to be saved using <c>UTF-16 LE</c> encoding. If you have saved the recording using
the content viewer launched by <see cref="M:Lumia.Sense.SenseRecording.SaveAsync" />, the content will be using <c>UTF-16 LE</c> encoding.</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example loads sensor recording from application's installation directory
<code>
SenseRecording recording = await SenseRecording.LoadFromFileAsync( "json.txt" );
</code></example>
        </member>
        <member name="M:Lumia.Sense.SenseRecording.SaveAsync">
            <summary>
Prompts user to save the recording in Json format in Documents folder
</summary>
            <returns>Asynchonous task</returns>
            <remarks>If you save the recording using the viewer launched by this method, the content will be saved using <c>UTF-16 LE</c> encoding.
Place make note of that when loading the recording using <c>LoadFromFileAsync</c>.</remarks>
            <exception cref="T:Platform.COMException">All errors are thrown as instances of <see cref="T:Platform.COMException" />. To get details about the error pass the
<see cref="P:Platform.Exception.HResult" /> property of the exception to <see cref="M:Lumia.Sense.SenseHelper.GetSenseError(System.Int32)" />.
This method can return the following <see cref="T:Lumia.Sense.SenseError" /> enumeration values: <see cref="F:Lumia.Sense.SenseError.GeneralFailure" /></exception>
            <example>
The following example shows how to record a sensor and prompt the user to share or save the recoding 
into a file in Documents folder.
<code lang="C#">
StepCounter _sensor = await StepCounter.GetDefaultAsync();
SenseRecorder _recorder = new SenseRecorder( _sensor );
await _recorder.StartAsync();
 ...
await _recorder.StopAsync();
SenseRecording recording = _recorder.GetRecording();
await recording.SaveAsync();

// If you want to play back the data, you can pass the recording to simulator.
SenseRecording recording = await SenseRecording.LoadFromFileAsync( "json.txt" );
StepCounterSimulator _simulator = await StepCounterSimulator.GetDefaultAsync( recording );
</code></example>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.Data">
            <summary>Recording data</summary>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.Version">
            <summary>Recording data file version</summary>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.Description">
            <summary>Description of the recording</summary>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.Duration">
            <summary>Duration of the recording</summary>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.StartTime">
            <summary>Date of the recording</summary>
        </member>
        <member name="P:Lumia.Sense.SenseRecording.Type">
            <summary>Recorded sensor type</summary>
        </member>
        <member name="T:Lumia.Sense.SenseRecording">
            <summary>
Container for <c>SenseRecorder</c> recording
</summary>
        </member>
    </members>
</doc>